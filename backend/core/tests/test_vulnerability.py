import pytest
from django.core.exceptions import ValidationError
from django.contrib.auth import get_user_model
from iam.models import Folder

from core.models import (
    Vulnerability,
)

from core.serializers import VulnerabilityImportExportSerializer

from .fixtures import *

User = get_user_model()


@pytest.fixture
def valid_vulnerability_data(
    domain_project_fixture, filtering_labels, applied_controls
):
    domain = Folder.objects.filter(content_type=Folder.ContentType.DOMAIN).first()
    filtering_labels = FilteringLabel.objects.all()
    applied_controls = AppliedControl.objects.all()
    return {
        "ref_id": "VULN-2025-001",
        "name": "SQL Injection in Login Form",
        "description": "A SQL injection vulnerability was found in the login form",
        "folder": str(domain.id),
        "status": Vulnerability.Status.EXPLOITABLE,
        "severity": 2,
        "filtering_labels": [label.label for label in filtering_labels[:2]],
        "applied_controls": [control.id for control in applied_controls[:2]],
        "created_at": "2025-01-13T10:00:00Z",
        "updated_at": "2025-01-13T10:00:00Z",
    }


@pytest.mark.django_db
class TestVulnerability:
    @pytest.mark.usefixtures(
        "filtering_labels", "domain_project_fixture", "applied_controls"
    )
    def test_basic_vulnerability_creation(self):
        vulnerability = Vulnerability.objects.create(
            name="SQL Injection in Login Form",
        )

        assert vulnerability is not None
        assert vulnerability.name == "SQL Injection in Login Form"
        assert vulnerability.ref_id == ""
        assert vulnerability.description is None
        assert vulnerability.folder == Folder.get_root_folder()
        assert vulnerability.status == Vulnerability.Status.UNDEFINED
        assert vulnerability.severity == -1
        assert vulnerability.filtering_labels.count() == 0
        assert vulnerability.applied_controls.count() == 0
        assert vulnerability.created_at is not None
        assert vulnerability.updated_at is not None

    @pytest.mark.usefixtures("domain_project_fixture")
    def test_vulnerability_creation_same_name_in_scope(self):
        domain = Folder.objects.filter(content_type=Folder.ContentType.DOMAIN).first()
        vulnerability = Vulnerability.objects.create(
            name="SQL Injection in Login Form", folder=domain
        )
        assert vulnerability is not None
        assert vulnerability.folder == domain

        with pytest.raises(ValidationError):
            Vulnerability.objects.create(
                name="SQL Injection in Login Form", folder=domain
            )

    def test_vulnerability_import_export_valid_data(self, valid_vulnerability_data):
        """Test serializer with valid data"""
        serializer = VulnerabilityImportExportSerializer(data=valid_vulnerability_data)
        assert serializer.is_valid(), f"Validation errors: {serializer.errors}"
        assert serializer.errors == {}

    def test_invalid_controls(self, valid_vulnerability_data):
        """Test with non-existent control IDs"""
        valid_vulnerability_data["applied_controls"] = [99999]  # Non-existent ID
        serializer = VulnerabilityImportExportSerializer(data=valid_vulnerability_data)
        assert not serializer.is_valid()
        assert "applied_controls" in serializer.errors

    def test_missing_required_fields(self):
        """Test with missing required fields"""
        incomplete_data = {}
        serializer = VulnerabilityImportExportSerializer(data=incomplete_data)
        assert not serializer.is_valid()
        for field in [
            "name",
        ]:
            assert field in serializer.errors

    def test_invalid_filtering_labels(self, valid_vulnerability_data):
        """Test with non-existent filtering labels"""
        valid_vulnerability_data["filtering_labels"] = ["non_existent_label"]
        serializer = VulnerabilityImportExportSerializer(data=valid_vulnerability_data)
        assert not serializer.is_valid()
        assert "filtering_labels" in serializer.errors

    def test_serialization(
        self, filtering_labels, domain_project_fixture, applied_controls
    ):
        """Test serializing an existing vulnerability instance"""
        folder = Folder.objects.filter(content_type=Folder.ContentType.DOMAIN).first()
        vulnerability = Vulnerability.objects.create(
            ref_id="VULN-2025-002",
            name="XSS in Comments",
            description="Cross-site scripting vulnerability in comments section",
            folder=folder,
            status="open",
            severity=3,
            created_at="2025-01-13T10:00:00Z",
            updated_at="2025-01-13T10:00:00Z",
        )
        vulnerability.filtering_labels.set(filtering_labels[:2])
        vulnerability.applied_controls.set(applied_controls[:2])

        serializer = VulnerabilityImportExportSerializer(vulnerability)
        data = serializer.data

        assert data["ref_id"] == "VULN-2025-002"
        assert data["name"] == "XSS in Comments"
        assert data["severity"] == 3
        assert data["folder"] == folder.id
        assert len(data["filtering_labels"]) == 2
        assert len(data["applied_controls"]) == 2
        assert isinstance(data["severity"], int)

    def test_empty_relationships(self, valid_vulnerability_data):
        """Test with empty relationships"""
        valid_vulnerability_data.update(
            {"filtering_labels": [], "applied_controls": []}
        )
        serializer = VulnerabilityImportExportSerializer(data=valid_vulnerability_data)
        assert serializer.is_valid(), f"Validation errors: {serializer.errors}"
        assert serializer.errors == {}

    def test_null_folder(self, valid_vulnerability_data):
        """Test with null folder if the field is nullable"""
        valid_vulnerability_data["folder"] = None
        serializer = VulnerabilityImportExportSerializer(data=valid_vulnerability_data)
        # This assertion depends on whether your folder field is nullable
        # Adjust based on your model's configuration
        if Vulnerability._meta.get_field("folder").null:
            assert serializer.is_valid(), f"Validation errors: {serializer.errors}"
        else:
            assert not serializer.is_valid()
            assert "folder" in serializer.errors
